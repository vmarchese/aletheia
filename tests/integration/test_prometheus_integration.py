"""Integration tests for Prometheus fetcher with real Prometheus server.

These tests require a running Prometheus instance accessible via HTTP.
Set the environment variable SKIP_PROMETHEUS_INTEGRATION=1 to skip these tests.

To run a local Prometheus instance with Docker:
    docker run -d -p 9090:9090 prom/prometheus

Or use an existing Prometheus server by setting PROMETHEUS_ENDPOINT environment variable.
"""

import os
from datetime import datetime, timedelta

import pytest
import requests

from aletheia.fetchers.prometheus import PrometheusFetcher, PROMQL_TEMPLATES
from aletheia.fetchers.base import ConnectionError, QueryError, AuthenticationError

# Skip all tests in this module if SKIP_PROMETHEUS_INTEGRATION is set
pytestmark = pytest.mark.skipif(
    os.getenv("SKIP_PROMETHEUS_INTEGRATION", "0") == "1",
    reason="Prometheus integration tests disabled (SKIP_PROMETHEUS_INTEGRATION=1)"
)


@pytest.fixture(scope="module")
def prometheus_endpoint():
    """Get Prometheus endpoint from environment or use default.
    
    Returns:
        str: Prometheus server URL
        
    Raises:
        pytest.skip: If Prometheus is not accessible
    """
    endpoint = os.getenv("PROMETHEUS_ENDPOINT", "http://localhost:9090")
    
    # Test if Prometheus is accessible
    try:
        response = requests.get(f"{endpoint}/api/v1/status/config", timeout=5)
        if response.status_code not in [200, 401]:  # 401 means auth required but server is up
            pytest.skip(f"Prometheus not accessible at {endpoint}")
    except requests.exceptions.RequestException:
        pytest.skip(f"Prometheus not accessible at {endpoint}")
    
    return endpoint


@pytest.fixture
def prometheus_fetcher(prometheus_endpoint):
    """Create a PrometheusFetcher instance with test configuration.
    
    Args:
        prometheus_endpoint: Prometheus server URL from fixture
        
    Returns:
        PrometheusFetcher: Configured fetcher instance
    """
    config = {
        "endpoint": prometheus_endpoint
    }
    return PrometheusFetcher(config)


@pytest.fixture
def prometheus_fetcher_with_auth(prometheus_endpoint):
    """Create a PrometheusFetcher with authentication (if configured).
    
    Args:
        prometheus_endpoint: Prometheus server URL from fixture
        
    Returns:
        PrometheusFetcher: Configured fetcher with auth
    """
    config = {
        "endpoint": prometheus_endpoint,
        "credentials": {
            "type": "env",
            "username_env": "PROMETHEUS_USERNAME",
            "password_env": "PROMETHEUS_PASSWORD"
        }
    }
    return PrometheusFetcher(config)


class TestPrometheusConnection:
    """Test Prometheus connectivity and configuration."""
    
    def test_connection_success(self, prometheus_fetcher):
        """Test successful connection to Prometheus server."""
        assert prometheus_fetcher.test_connection() is True
    
    def test_connection_with_invalid_endpoint(self):
        """Test connection failure with invalid endpoint."""
        config = {
            "endpoint": "http://localhost:19999"  # Unlikely to be in use
        }
        fetcher = PrometheusFetcher(config)
        assert fetcher.test_connection() is False
    
    def test_connection_with_malformed_endpoint(self):
        """Test connection with malformed endpoint URL."""
        config = {
            "endpoint": "not-a-valid-url"
        }
        with pytest.raises(ValueError, match="Invalid endpoint URL"):
            PrometheusFetcher(config)
    
    def test_capabilities(self, prometheus_fetcher):
        """Test that fetcher reports correct capabilities."""
        capabilities = prometheus_fetcher.get_capabilities()
        
        assert "supports_time_window" in capabilities
        assert capabilities["supports_time_window"] is True
        assert "data_types" in capabilities
        assert "metrics" in capabilities["data_types"]
        assert "supports_templates" in capabilities
        assert capabilities["supports_templates"] is True


class TestPrometheusQueryExecution:
    """Test query execution with real Prometheus."""
    
    def test_query_up_metric(self, prometheus_fetcher):
        """Test querying the 'up' metric which should always exist."""
        # The 'up' metric is generated by Prometheus itself
        result = prometheus_fetcher.fetch(query="up")
        
        assert result.source == "prometheus"
        assert isinstance(result.data, list)
        # Should have at least one time series for Prometheus itself
        assert result.count > 0
    
    def test_query_with_time_window(self, prometheus_fetcher):
        """Test querying with a time window."""
        end_time = datetime.now()
        start_time = end_time - timedelta(minutes=30)
        time_window = (start_time, end_time)
        
        result = prometheus_fetcher.fetch(
            query="up",
            time_window=time_window
        )
        
        assert result.source == "prometheus"
        assert isinstance(result.data, list)
        assert result.time_range == time_window
    
    def test_query_with_custom_step(self, prometheus_fetcher):
        """Test querying with custom step size."""
        end_time = datetime.now()
        start_time = end_time - timedelta(hours=1)
        time_window = (start_time, end_time)
        
        result = prometheus_fetcher.fetch(
            query="up",
            time_window=time_window,
            step="1m"
        )
        
        assert result.source == "prometheus"
        assert isinstance(result.data, list)
    
    def test_query_rate_function(self, prometheus_fetcher):
        """Test querying with rate function."""
        end_time = datetime.now()
        start_time = end_time - timedelta(minutes=15)
        time_window = (start_time, end_time)
        
        # Query rate of up metric changes
        result = prometheus_fetcher.fetch(
            query="rate(up[1m])",
            time_window=time_window
        )
        
        assert result.source == "prometheus"
        assert isinstance(result.data, list)


class TestPrometheusTemplates:
    """Test PromQL template system."""
    
    def test_request_rate_template(self, prometheus_fetcher):
        """Test request_rate template (if applicable metrics exist)."""
        end_time = datetime.now()
        start_time = end_time - timedelta(minutes=15)
        time_window = (start_time, end_time)
        
        try:
            result = prometheus_fetcher.fetch(
                template="request_rate",
                template_params={
                    "metric_name": "up",  # Use 'up' as a test metric
                    "service": "prometheus",
                    "window": "1m"
                },
                time_window=time_window
            )
            
            assert result.source == "prometheus"
            assert isinstance(result.data, list)
        except QueryError:
            # Template might not match available metrics
            pytest.skip("Template query not applicable to available metrics")
    
    def test_template_with_missing_params(self, prometheus_fetcher):
        """Test template with missing required parameters."""
        with pytest.raises(QueryError, match="Missing template parameter"):
            prometheus_fetcher.fetch(
                template="request_rate",
                template_params={"service": "test"}  # Missing metric_name and window
            )
    
    def test_invalid_template_name(self, prometheus_fetcher):
        """Test using non-existent template."""
        with pytest.raises(QueryError, match="Unknown template"):
            prometheus_fetcher.fetch(
                template="nonexistent_template",
                template_params={}
            )


class TestPrometheusErrorScenarios:
    """Test error handling in Prometheus operations."""
    
    def test_invalid_promql_syntax(self, prometheus_fetcher):
        """Test handling of invalid PromQL syntax."""
        with pytest.raises(QueryError):
            prometheus_fetcher.fetch(query="invalid{{{query}}")
    
    def test_query_nonexistent_metric(self, prometheus_fetcher):
        """Test querying a metric that doesn't exist."""
        result = prometheus_fetcher.fetch(query="nonexistent_metric_12345")
        
        # Should return empty result, not error
        assert result.source == "prometheus"
        assert isinstance(result.data, list)
        assert result.count == 0
    
    def test_timeout_handling(self, prometheus_endpoint):
        """Test query timeout handling."""
        config = {
            "endpoint": prometheus_endpoint,
            "timeout": 1  # Very short timeout
        }
        fetcher = PrometheusFetcher(config)
        
        # Complex query that might timeout
        try:
            result = fetcher.fetch(query="up")
            # If it succeeds, that's fine too
            assert result.source == "prometheus"
        except ConnectionError:
            # Timeout should be caught as ConnectionError
            pass
    
    def test_missing_query_and_template(self, prometheus_fetcher):
        """Test fetch without query or template."""
        with pytest.raises(ValueError, match="query or template"):
            prometheus_fetcher.fetch()


class TestPrometheusDataQuality:
    """Test data quality and consistency."""
    
    def test_data_format(self, prometheus_fetcher):
        """Test that fetched data has consistent format."""
        result = prometheus_fetcher.fetch(query="up")
        
        # Data should be a list of time series
        assert isinstance(result.data, list)
        
        if result.count > 0:
            # Each time series should have metric and values
            for series in result.data:
                assert isinstance(series, dict)
                assert "metric" in series or "values" in series
    
    def test_summary_generation(self, prometheus_fetcher):
        """Test that summary is generated correctly."""
        result = prometheus_fetcher.fetch(query="up")
        
        assert isinstance(result.summary, str)
        assert len(result.summary) > 0
        
        # Summary should mention count and metrics
        if result.count > 0:
            assert "time series" in result.summary or "data point" in result.summary
    
    def test_time_range_accuracy(self, prometheus_fetcher):
        """Test that returned time range matches request."""
        end_time = datetime.now()
        start_time = end_time - timedelta(minutes=10)
        time_window = (start_time, end_time)
        
        result = prometheus_fetcher.fetch(
            query="up",
            time_window=time_window
        )
        
        assert result.time_range == time_window
    
    def test_metadata_includes_query(self, prometheus_fetcher):
        """Test that metadata includes the executed query."""
        query = "up"
        result = prometheus_fetcher.fetch(query=query)
        
        assert isinstance(result.metadata, dict)
        assert "query" in result.metadata
        assert result.metadata["query"] == query
    
    def test_count_matches_data_length(self, prometheus_fetcher):
        """Test that count field matches actual data length."""
        result = prometheus_fetcher.fetch(query="up")
        
        # Count should reflect number of time series
        assert result.count == len(result.data)


class TestPrometheusAdaptiveResolution:
    """Test adaptive metric resolution."""
    
    def test_short_time_window_resolution(self, prometheus_fetcher):
        """Test resolution for short time windows (< 1 hour)."""
        end_time = datetime.now()
        start_time = end_time - timedelta(minutes=30)
        time_window = (start_time, end_time)
        
        result = prometheus_fetcher.fetch(
            query="up",
            time_window=time_window
        )
        
        # Should use fine-grained resolution (15s)
        # Check metadata for step if available
        if "step" in result.metadata:
            assert result.metadata["step"] == "15s"
    
    def test_medium_time_window_resolution(self, prometheus_fetcher):
        """Test resolution for medium time windows (1-6 hours)."""
        end_time = datetime.now()
        start_time = end_time - timedelta(hours=3)
        time_window = (start_time, end_time)
        
        result = prometheus_fetcher.fetch(
            query="up",
            time_window=time_window
        )
        
        # Should use 1m resolution
        if "step" in result.metadata:
            assert result.metadata["step"] == "1m"
    
    def test_long_time_window_resolution(self, prometheus_fetcher):
        """Test resolution for long time windows (> 7 days)."""
        end_time = datetime.now()
        start_time = end_time - timedelta(days=10)
        time_window = (start_time, end_time)
        
        result = prometheus_fetcher.fetch(
            query="up",
            time_window=time_window
        )
        
        # Should use coarse resolution (1h)
        if "step" in result.metadata:
            assert result.metadata["step"] == "1h"


class TestPrometheusAuthentication:
    """Test authentication scenarios (if auth is configured)."""
    
    def test_basic_auth_success(self, prometheus_endpoint):
        """Test basic authentication if credentials are provided."""
        username = os.getenv("PROMETHEUS_USERNAME")
        password = os.getenv("PROMETHEUS_PASSWORD")
        
        if not username or not password:
            pytest.skip("PROMETHEUS_USERNAME and PROMETHEUS_PASSWORD not set")
        
        config = {
            "endpoint": prometheus_endpoint,
            "credentials": {
                "type": "basic",
                "username": username,
                "password": password
            }
        }
        fetcher = PrometheusFetcher(config)
        
        # Should connect successfully
        assert fetcher.test_connection() is True
    
    def test_bearer_token_auth(self, prometheus_endpoint):
        """Test bearer token authentication if configured."""
        token = os.getenv("PROMETHEUS_TOKEN")
        
        if not token:
            pytest.skip("PROMETHEUS_TOKEN not set")
        
        config = {
            "endpoint": prometheus_endpoint,
            "credentials": {
                "type": "bearer",
                "token": token
            }
        }
        fetcher = PrometheusFetcher(config)
        
        # Should connect successfully
        assert fetcher.test_connection() is True
    
    def test_invalid_credentials(self, prometheus_endpoint):
        """Test authentication failure with invalid credentials."""
        # This test only makes sense if the server requires auth
        # Try with obviously wrong credentials
        config = {
            "endpoint": prometheus_endpoint,
            "credentials": {
                "type": "basic",
                "username": "invalid_user_12345",
                "password": "invalid_pass_12345"
            }
        }
        fetcher = PrometheusFetcher(config)
        
        # May fail connection test or succeed if server doesn't require auth
        # We're just testing that it doesn't crash
        try:
            result = fetcher.test_connection()
            # If server doesn't require auth, connection will succeed
            assert isinstance(result, bool)
        except AuthenticationError:
            # Expected if server requires auth
            pass


class TestPrometheusPerformance:
    """Test performance characteristics."""
    
    def test_large_time_window(self, prometheus_fetcher):
        """Test querying a large time window."""
        end_time = datetime.now()
        start_time = end_time - timedelta(days=7)
        time_window = (start_time, end_time)
        
        result = prometheus_fetcher.fetch(
            query="up",
            time_window=time_window
        )
        
        # Should complete without timeout
        assert result.source == "prometheus"
        assert isinstance(result.data, list)
    
    def test_complex_query(self, prometheus_fetcher):
        """Test executing a complex PromQL query."""
        end_time = datetime.now()
        start_time = end_time - timedelta(hours=1)
        time_window = (start_time, end_time)
        
        # Complex aggregation query
        complex_query = 'sum(rate(up[1m])) by (job)'
        
        result = prometheus_fetcher.fetch(
            query=complex_query,
            time_window=time_window
        )
        
        # Should complete without error
        assert result.source == "prometheus"
        assert isinstance(result.data, list)
